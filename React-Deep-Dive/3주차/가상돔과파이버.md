# DOM과 브라우저 렌더링

브라우저 렌더링은 아래의 과정을 따른다

1. html 다운
2. DOM트리를 만든다
3. CSS 다운
4. CSS OM트리를 만든다
5. DOM을 순회 (display:none 제외)
6. CSS를 적용하는데 레이아웃 layout, painting 과정으로 나뉜다.

- 레이아웃 (layout reflow) : 각 노드가 브라우저에 어느 좌표에 정확히 나타날지 계산.
- 페인팅 : 레이아웃 단계를 거친 노드를 실제로 그리는 과정

# 가상DOM

특정 요소의 색상만 바뀌는경우 레이아웃 -> 페인트 과정이 들기때문에, 브라우저 자원이 많이 쓰임

가상DOM(react-dom)은 메모리에 저장된 가상의 DOM이며, 최종 렌더링은 1번만 일어나게해줌

한가지 오해는, 모든 상황에서 브라우저 렌더링보다 가상돔이 빠르다는 오해인데, 렌더링이 활발하지않은 경우엔 직접 DOM을 렌더링하는게 더 나을수있다.

# 파이버 노드

## 파이버란?

- 가상돔과 실제돔을 비교했을때 변화가 생겼는지를 판단하는 기준
- fiber reconciler가 관리함.
- reconciler는 재조정자로, 가상돔과 실제돔의 변화를 비교하는 작업(알고리즘)이다.
- 하나의 작업이 처리되면 `finishedWork()`로 작업을 마무리함.

## 파이버 동작

1. 렌더단계에서 비동기 작업(사용자에게 노출되지않음)을 수행하고 `finishedWork()`로 작업을 마무리함.
2. 비동기 작업들이 마무리되면 `commitWork()`이 실행되고 DOM에 실제 변경사항을 반영.

## 파이버 역할

애니메이션, 인터랙션에 올바른 결과물을 만드는 `반응성 문제`를 해결하며 아래와같은 일을 한다.

- 작업을 작은 단위로 쪼갠뒤 우선순위
- 작업을 일시중지, 나중에 다시 시작
- 이전작업을 재사용 하거나 폐기

## 파이버의 구성

1. tag : 하나의 Element에 1:1로 대응됨.functionalComponent, classComponent,ref, div 등등
2. stateNode : 파이버 자체에 대한 참조 정보. (리액트는 이를 통해 접근)
3. child, sibling, return : 파이버 간의 관계 개념을 나타냄
4. pendngProps : 아직 적업을 처리하지못한 props
5. memoizedProps : pendngProps를 기준으로 렌더링이 완료된 이후에 변경될 props
6. updateQueue : 상태 업데이트 콜백 함수. DOM업데이트 등 필요한 작업을 담아두는 큐.
7. memoizedState : 함수 컴포넌트의 훅 목록이 저장됨(모든 훅)
8. alternate : 파이버 트리에서 반대편 트리 (현재트리 <-> workInProgress)를 가르킴

## 파이버 특징

- 모든 과정이 비동기로 동작함
- 리액트 요소와 다르게, 가급적 재사용된다
- 파이버 트리는 state가 변경되거나, 생명주기 메서드가 실행되는등 상황에 실행된다

> 기존의 리액트의 조정(reconciler) 알고리즘은 스택 알고리즘이었는데, 이는 동기적이고 한번 시작되면 중단이 불가능했음.
> 리액트 파이버는 이런 단점을 해결

# 파이버 트리

파이버 트리는 2개의 구성요소로 이루어져있다

1. 현재 트리 (=== `current`)
2. 작업중인 상태 트리 (=== `workInProgress`)

파이버의 작업이 끝나면, 단순 포인터만 변경해 workInProgress트리를 현재트리로 변경하는 더블 버퍼링이 일어난다.

이는 커밋 단계에서 일어난다.

> 더블 버퍼링이란, A -> B로 변경될때 보이지 않는곳에서 B를 미리 그려놓고 바꾸는 기법. B가 그려지는 과정이 화면에 노출되지않음

즉, 현재 UI렌더링을 위해 current 트리 기준으로 작업이 시작되며 업데이트가 발생하면 파이버는 workInProgress 트리를 빌드한다.
workInProgress 빌드가 끝나면 다음 렌더링에 workInProgress가 사용되며 반영 완료시 workInProgress가 current로 더블 버퍼링된다.

## 파이버 작업 순서

1. `beginWork()` 로 파이버 작업 수행. (더이상 자식이 없는 파이버까지)
2. 작업이 끝나면 `completeWork()`실행 하여 작업완료
3. 형제가 있다면 형제로
4. 모두 끝나면 return으로 돌아가 작업 완료를 알림.

예시.

```js
<A1>
  <B1></B1>
  <B2>
    <C1></C1>
    <C2></C2>
  </B2>
  <B3></B3>
</A1>
```

1. A1에서 beginWork()
2. A1의 child를 타고 B1에서 beginWork()
3. B1은 child가 없으므로 completeWork() -> B2로 sibling
4. B2에서 beginWork()
5. B2에서 child타고 C1에서 beginWork()
6. C1은 child가 없으므로 completeWork() -> C2로 sibling
7. C2도 자식이 없으므로 completeWork()
8. 더이상 child, siblings가 없으므로 위로 이동해서 C1, B2순서로 completeWork()
9. B3로 sibling -> B3 beginWork()
10. A1 completeWork()
11. commitWork()

> 여기서 setState등 업데이트가 발생하면?

current트리가 존재하므로 workInProgress트리를 빌드하는데, 새로 생성하지않고 앞서 만든 트리를 재활용한다.

> 기존의 스택 아키텍쳐는, 여기서 트리업데이트, 재귀적인 트리 순회를 멈출 수 없었다.

파이버 단위로 관리되고나서는 현재 작업을 일시중단, 폐기, 우선순위 조정이 가능해졌다

이래서 useTransition 같은 훅이 가능했던거구나?!

# 정리

기존의 Stack 아키텍쳐는, 동기적으로 동작하여 중간에 멈추거나, 일시정지하거나, 우선순위를 두는게 불가능하여 효율적이지 못했다.

리액트는 재조정 작업을 파이버라는 단위로 쪼개고 비동기적으로 작동하므로 작업의 우선순위를 두거나, 일시정지, 폐기하는등 유연하게 동작할수있게 됐다.

또한 매번의 재조정마다 파이버 트리를 만들지않고, 최초에만 생성하고 이후에는 트리를 재활용하며 변경된 상태들을 업데이트 하는 방식으로 운영한다.

실제 DOM에 반영되기전에 current 트리 -> workInProgress 트리로 포인터만 변경되어 더블 버퍼링된다. 따라서 DOM이 그려지는 과정이 화면에 노출되지 않는다.
