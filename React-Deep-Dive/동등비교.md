# 동등비교?

## 자바스크립트에서 동등비교

### 자바스크립트 데이터 타입

#### 원시타입

- boolean
- null
- undefined
- number
- string
- symbol
- bigint

#### 객체타입

- object

### 값을 저장하는 방식차이

원시타입과 객체타입의 가장 큰 차이점은 저장하는 방식의 차이다.

- 원시타입 : 불변형태로 저장되며 변수 할당 시점에 메모리 영역을 차지하고 저장됨

- 객체타입 : 변경가능한 형태로 저장되며, 값이 아닌 참조를 저장하므로 동일하게 선언한 객체라도 참조가 다르므로 비교시에 false를 반환한다.

### Object.is

`Object.is`는 `==`, `===` 연산자와 차이점이 있다.

`==` : 양쪽의 값의 타입이 다른경우, 강제로 형변환(type casting)을 한 뒤 비교한다.

`===` : 타입까지 비교하지만, 아래의 경우 기대하는것과 다르게 동작할수있음

`Object.is` : 아래의 경우 `===`보다 개발자 기대에 부합하는 정확한 비교를 한다

```js
-0 === +0; // true
Obejct.is(-0, +0); // false

Number.NAN === NAN; // false
Object.is(Number.NAN, NAN); // true

NAN === 0 / 0; // false
Object.is(Number.NAN, NAN); // true
```

하지만 Object.is도 객체비교에는 `===`와 별 차이가 없음.

### 리액트에서의 동등 비교

리액트에서는 Object.is를 기반으로 동등비교를 하는 `shallowEqual`이라는 함수를 만들어서 사용한다

- 의존성 비교등 리액트의 동등 비교가 필요한 다양한 곳에서 사용된다.
- 1depth까지 객체의 비교가 가능하다 (깊은 비교는 불가)

리액트에서 사용하는 jsx props는 객체형태이고 props는 일반적인 케이스에서 1depth 동등 비교로 충분하다.

따라서 props를 2depth이상 사용하는경우 렌더링이 예상치 못하게 작동 될 수 있다.

여기서 shallowEqual을 재귀적으로 사용하지 않고 얕은 비교까지만 하는 이유는 뭘까?

- 객체안이 몇 depth인지 모르므로 성능에 악영향을 끼칠 수 있음.

# 정리

- 리액트에서 props는 객체형태이다.
- 리액트 내부적으로 동작하는 `shallowEqual` 이란 함수는 객체의 얕은비교를 수행한다.
- 따라서 props는 1depth의 객체로 유지하는것이 의도치않은 렌더링을 수행하는것을 막을 수 있다.
