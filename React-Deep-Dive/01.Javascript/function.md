# 함수

리액트에서의 Component는 함수와 유사하다.

- Component라는 함수를 선언하고
- Props라는 객체 인수를 넘겨주며
- JSX를 return 한다.
- 일반적인 자바스크립트 함수호출로 Component를 호출하는것도 가능하다.

## 함수를 정의하는 방법 4가지

### 함수 선언문

```js
function add(a, b) {
  return a + b;
}
```

- 선언문은 호이스팅 된다
- 코드내에서 명시적으로 함수를 구분하고 싶은경우 선언문 사용

### 함수 표현식

```js
const sum = function (a, b) {
  return a + b;
};

const sum = function add() {
  // add는 외부에서 호출되지않는 내부 식별자
  return a + b;
};
```

### 생성자 함수

권장되지않음.

### 화살표 함수

ES6에서 추가된 방식으로 아래와 같은 특징이 있다.

- constructor 사용 불가.
- arguments 존재 X
- 상위 스코프의 this를 그대로 따른다 \*
  - 일반함수에서의 this는 함수가 어떻게 호출되냐에따라 달라지며, 일반적으로 전역객체 window를 가르킨다
  - 화살표 함수는 자체의 바인딩을 가지지않으며 상위의 this를 그대로 따른다.

_바벨 트랜스 파일링 이전_

```js
const arrowFn = () => {
  console.log(this);
};

function normalFn() {
  console.log(this);
}
```

_바벨 트랜스 파일링 이후_

```js
var _this = void 0;

var arrowFn = function arrowFn() {
  console.log(_this); // 화살표 함수는 undefined로 바뀐 _this를 따른다
};

function normalFn() {
  console.log(this); // 일반 함수에서는 this를 그대로 따른다
}
```

> 특히, this를 사용할수밖에 없는 클래스형 컴포넌트에서 화살표 함수와 일반함수를 주의하며 사용해야한다.

## 다양한 함수

### 즉시실행 함수 (IIFE)

- IIFE는 독립적인 함수 스코프를 운용할수있다.
- 재사용되지않는다.
- 선언과 실행이 바로 그 자리에서 끝나므로, 외부에서 내부의 값에는 접근이 불가능.

```js
(function (a, b) {
  return a + b;
})(
  1,
  2
)(
  // 3

  (a, b) => {
    return a + b;
  }
)(1, 2); // 3
```

### 고차함수 (HOF)

자바스크립트에서의 함수는 일반적인 연산이 가능한 일급객체이므로, 이런 특징을 활용해서 함수를 인수로 받거나, 결과로 새로운 함수를 반환하는 고차함수를 만들 수 있다.

```js
const add = function (a) {
  return function (b) {
    return a + b;
  };
};

add(1)(2); // 3
```

## 주의사항

### 부수효과를 최대한 억제하라.

> 부수효과란, 함수 작동으로 외부에 영향을 끼치는것

> 순수함수란, 언제 어디서나 동일한 인수를 받아 동일한 결과를 반환하는 함수

- 순수함수를 통해 외부로의 영향을 최소화 하는것이 안정적인 어플리케이션 개발에 좋다.

- 리액트에서는 useEffect를 최소화 해서 예측가능한 애플리케이션 개발을 지향하자.

### 가능한 함수를 작게 만들어라

- `max-lines-per-function`같이 린트에서도 함수의 라인수를 제한할수있다.
- 정해진 라인수는 의미없지만, 그만큼 함수하나의 역할을 독립적이고 작게 만드는것이 중요함.
- SOLID에서의 S(SRP)관점을 생각

### 누구나 이해할수있는 이름을 붙여라.

- 한글로 함수,변수명을 지을수도있다 -> 번들링에 약간의 부담 증가. 좋은 방법은 아닌듯

# 정리

- 자바스크립트에서의 함수는 일급객체이고, 리액트의 Component는 함수와 유사하다.
- 함수는 선언문, 표현식, 생성자, 화살표함수 여러 방식으로 선언가능하다. (호이스팅과, this의 관점에서 차이가 있음)
- 순수함수는 외부에 영향을 끼치지않아 부수효과를 최소화할수있다. 이 관점에서 리액트에서는 useEffect를 최소화 할 필요가있다
